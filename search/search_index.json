{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Linux/","title":"Linux","text":""},{"location":"Linux/posts/Development_toolkits/","title":"Development toolkits","text":""},{"location":"Linux/posts/Development_toolkits/#bash","title":"Bash","text":"<p>Bash Command Line Args (dbp-consulting.com)</p>"},{"location":"Linux/posts/Development_toolkits/#gdb","title":"GDB","text":"<p>Asm Debugging With GDB (dbp-consulting.com)</p>"},{"location":"Linux/posts/Development_toolkits/#unix-faqs","title":"UNIX FAQs","text":"<p>Original cup faq (dbp-consulting.com)</p>"},{"location":"Linux/posts/Docker/","title":"Docker","text":""},{"location":"Linux/posts/Docker/#docker","title":"Docker","text":""},{"location":"Linux/posts/Docker/#image","title":"Image","text":"<p>\u7c7b\u4f3c\u4e00\u4e2a\u9759\u6001\u7684\u6587\u4ef6\u7cfb\u7edf\uff08\u865a\u62df\u673a\u7684\u5feb\u7167 snapshot\uff09\uff0c\u63d0\u4f9b\u4e86\u8fd0\u884c\u65f6\u6240\u9700\u7684</p> <ul> <li>\u7a0b\u5e8f</li> <li>\u5e93</li> <li>\u8d44\u6e90</li> <li>\u914d\u7f6e</li> </ul>"},{"location":"Linux/posts/Docker/#build-a-image","title":"Build a image","text":"<p>from Containerize an application | Docker Docs</p> <p>Github repo: docker/getting-started-app: A simple application for the getting started guide in Docker's documentation (github.com)</p> <p>Create a <code>Dockerfile</code> at <code>/path/to/getting-started-app</code></p> <pre><code># syntax=docker/dockerfile:1\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY . .\nRUN yarn install --production\nCMD [\"node\", \"src/index.js\"]\nEXPOSE 3000\n</code></pre> <p>Build the image in the terminal:</p> <pre><code>cd /path/to/getting-started-app\n\ndocker build -t getting-started .\n</code></pre> <ul> <li><code>-t</code>: tag your container name, in this case: getting-started</li> <li><code>.</code>: the path where Docker should find the <code>Dockerfile</code></li> </ul>"},{"location":"Linux/posts/Docker/#container","title":"Container","text":"<p>Run your container using <code>docker run</code>:</p> <pre><code>docker run -dp 127.0.0.1:3000:3000 getting-started\n</code></pre> <ul> <li><code>-d</code>: <code>--detach</code> runs in the background</li> <li><code>-p</code>: <code>--publish</code> takes a string value in the format of <code>HOST:CONTAINER</code><ul> <li><code>HOST</code>: the address on the host, in this case: <code>127.0.0.1:3000</code></li> <li><code>CONTAINER</code>: the port on the container, in this case: <code>3000</code></li> </ul> </li> </ul> <p>then you open web browser to <code>http://localhost:3000</code> to access the app service</p>"},{"location":"Linux/posts/Docker/#filesystem","title":"Filesystem","text":"<ul> <li>Each container has its own \"scratch space\" to create/update/remove files.</li> <li>Other containerse won't see the changes</li> </ul> <p>Start an <code>ubuntu</code> container that will create a file named <code>/data.txt</code> with a random number between 1 and 10000:</p> <pre><code>docker run -d ubuntu bash -c \"shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null\"\n</code></pre> <p>in CLI, use the <code>docker exec</code> command to access the container (use <code>docker ps</code> to get the container's ID):</p> <pre><code>docker exec &lt;container-id&gt; cat /data.txt\n</code></pre> <p>But in another container using same image, you can't see the <code>data.txt</code></p>"},{"location":"Linux/posts/Docker/#volumes","title":"Volumes","text":"<p>man page: Volumes | Docker Docs</p> <p>Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. If you mount a directory in the container, changes in that directory are also seen on the host machine. If you mount that same directory across container restarts, you'd see the same files.</p> <p></p>"},{"location":"Linux/posts/Docker/#mount","title":"Mount","text":"<p>Create a volume and start the container</p> <pre><code>docker volume create todo-db\n</code></pre> <p>the specific location of volume on the host machine is implicitly set by the docker</p> <p>Start the todo app container, but add the <code>--mount</code> option to specify a volume mount</p> <pre><code>docker run -dp 127.0.0.1:3000:3000 --mount type=volume,src=todo-db,target=/etc/todos getting-started\n</code></pre> <ul> <li><code>src</code>: the volume you want to mount</li> <li><code>target</code>: the file path in the container</li> </ul> <p>Delve deeper to see where docker storing my data using volume</p> <pre><code>$ docker volume inspect todo-db\n[\n    {\n        \"CreatedAt\": \"2019-09-26T02:18:36Z\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/todo-db/_data\",\n        \"Name\": \"todo-db\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n</code></pre> <p><code>Mountpoint</code>\uff1athe actual location of the data in the disk</p>"},{"location":"Linux/posts/Docker/#bind","title":"Bind","text":"<p>Comparison with Mount</p> Mount Bind Host location Docker chooses You chooses params in <code>--mount</code> <code>type=volume,src=my-volume-name,target=/usr/local/data</code> <code>type=bind,src=/path/to/data,target=/usr/local/data</code>"},{"location":"Linux/posts/Docker/#repository","title":"Repository","text":""},{"location":"Linux/posts/Docker/#docker-compose","title":"Docker Compose","text":""},{"location":"Linux/posts/Linux_network-related_scripts/","title":"Linux network related scripts","text":""},{"location":"Linux/posts/Linux_network-related_scripts/#network-interface","title":"Network interface","text":""},{"location":"Linux/posts/Linux_network-related_scripts/#check-whether-a-network-interface-is-physical-device-or-virtual-alias","title":"Check whether a network interface is physical (device) or virtual (alias)?","text":"<p><code>ifconfig</code></p> <p>We can simply use <code>ifconfig</code> (deprecated) to quickly the current network interfaces</p> <pre><code>$ ifconfig\nlo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536\n        inet 127.0.0.1  netmask 255.0.0.0\n        loop  txqueuelen 1000  (Local Loopback)\n        RX packets 141923345  bytes 28793753296 (28.7 GB)\n        RX errors 0  dropped 0  overruns 0  frame 0\n        TX packets 141923345  bytes 28793753296 (28.7 GB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n</code></pre> <p>some outputs:</p> <ul> <li><code>inet</code>: protocol names (TCP/IP, default), others:<ul> <li><code>inet6</code> (IPv6)</li> </ul> </li> </ul> <p>For more detailed information, like whether a network interface is physical (device) or virtual (alias), we can use:</p> <pre><code>$ ls -l /sys/class/net/\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 docker0 -&gt; ../../devices/virtual/net/docker0\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 eno1 -&gt; ../../devices/pci0000:00/0000:00:1c.2/0000:02:00.0/net/eno1\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 eno2 -&gt; ../../devices/pci0000:00/0000:00:1c.2/0000:02:00.1/net/eno2\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 eno3 -&gt; ../../devices/pci0000:00/0000:00:1c.3/0000:03:00.0/net/eno3\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 eno4 -&gt; ../../devices/pci0000:00/0000:00:1c.3/0000:03:00.1/net/eno4\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 enp5s0 -&gt; ../../devices/pci0000:00/0000:00:03.0/0000:05:00.0/net/enp5s0\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 enp5s0d1 -&gt; ../../devices/pci0000:00/0000:00:03.0/0000:05:00.0/net/enp5s0d1\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 lo -&gt; ../../devices/virtual/net/lo\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 virbr0 -&gt; ../../devices/virtual/net/virbr0\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 virbr0-nic -&gt; ../../devices/virtual/net/virbr0-nic\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 virbr2 -&gt; ../../devices/virtual/net/virbr2\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 virbr2-nic -&gt; ../../devices/virtual/net/virbr2-nic\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 virbr3 -&gt; ../../devices/virtual/net/virbr3\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 virbr3-nic -&gt; ../../devices/virtual/net/virbr3-nic\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 vnet0 -&gt; ../../devices/virtual/net/vnet0\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 vnet1 -&gt; ../../devices/virtual/net/vnet1\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 vnet2 -&gt; ../../devices/virtual/net/vnet2\nlrwxrwxrwx 1 root root 0 Mar 11 07:35 vnet3 -&gt; ../../devices/virtual/net/vnet3\n</code></pre> <p>We can distinct this output by checking <code>../../devices/{class}/net/{device name}</code>:</p> <ul> <li>if <code>{class}</code> is virtual, it is a virtual device</li> </ul>"},{"location":"Linux/posts/Linux_network-related_scripts/#check-whether-is-tuntap-bridges-etc","title":"Check whether is TUN/TAP, Bridges, etc.","text":"<pre><code>$ ip -details tuntap\nvirbr3-nic: tap persist\n        Attached to processes:\nvirbr2-nic: tap persist\n        Attached to processes:\n</code></pre> <ul> <li>Physical devices have a <code>/sys/class/net/eth0/device</code> symlink</li> <li>Bridges have a <code>/sys/class/net/br0/bridge</code> directory</li> <li>TUN and TAP devices have a <code>/sys/class/net/tap0/tun_flags</code> file</li> <li>Bridges and loopback interfaces have <code>00:00:00:00:00:00</code> in <code>/sys/class/net/lo/address</code></li> </ul>"},{"location":"Linux/posts/Linux_network-related_scripts/#flow-generating","title":"Flow generating","text":"<p>Understanding host network stack overheads</p> <ul> <li>for generating long flows, we use a standard network benchmarking tool, iPerf [14], which transmits a flow from sender to receiver; </li> <li>for generating short flows, we use netperf [22] that supports pingpong style RPC workloads.</li> </ul>"},{"location":"Linux/posts/Linux_network-related_scripts/#iptables-nfqueue","title":"iptables-nfqueue","text":"<p>https://asphaltt.github.io/post/iptables-nfqueue/</p> <p>https://home.regit.org/netfilter-en/using-nfqueue-and-libnetfilter_queue/</p>"},{"location":"Linux/posts/Linux_network-related_scripts/#network-namespace","title":"network namespace","text":"<p>comprehensive turoial</p>"},{"location":"Linux/posts/Linux_network-related_scripts/#congestion-control","title":"congestion control","text":"<p>one-article-fit-all</p> <p>load and change cc</p>"},{"location":"Linux/posts/Linux_network-related_scripts/#proxy","title":"proxy","text":"<p>http/https proxy</p>"},{"location":"Linux/posts/Linux_network_TUN-TAP_tutorial/","title":"Linux network TUN TAP tutorial","text":""},{"location":"Linux/posts/Linux_network_TUN-TAP_tutorial/#references","title":"References","text":"<p>[1] Tun/Tap interface tutorial</p> <p>[2] Demystifying VPN Tunnels</p> <p>[3] Understanding the /dev Directory in Linux</p> <p>[4] File descriptors explained</p> <p>[5] Here is all you need to know about File Descriptors in linux</p>"},{"location":"Linux/posts/Linux_network_stack/","title":"Linux network stack","text":""},{"location":"Linux/posts/Linux_network_stack/#case-study-receiving-data","title":"Case study: Receiving data","text":""},{"location":"Linux/posts/Linux_network_stack/#high-level-data-path","title":"High-level data path","text":"<p>The high level path a packet takes from arrival to socket receive buffer is as follows:</p> <ol> <li>Driver is loaded and initialized.</li> <li>Packet arrives at the NIC from the network.</li> <li>Packet is copied (via DMA) to a ring buffer in kernel memory.</li> <li>Hardware interrupt is generated to let the system know a packet is in memory.</li> <li>Driver calls into NAPI to start a poll loop if one was not running already.</li> <li><code>ksoftirqd</code> processes run on each CPU on the system. They are registered at boot time. The <code>ksoftirqd</code> processes pull packets off the ring buffer by calling the NAPI <code>poll</code> function that the device driver registered during initialization.</li> <li>Memory regions in the ring buffer that have had network data written to them are unmapped.</li> <li>Data that was DMA\u2019d into memory is passed up the networking layer as an \u2018skb\u2019 for more processing.</li> <li>Incoming network data frames are distributed among multiple CPUs if packet steering is enabled or if the NIC has multiple receive queues.</li> <li>Network data frames are handed to the protocol layers from the queues.</li> <li>Protocol layers process data.</li> <li>Data is added to receive buffers attached to sockets by protocol layers.</li> </ol>"},{"location":"Linux/posts/Linux_network_stack/#detailed-process","title":"Detailed process","text":"<p>This blog post will look at the <code>igb</code> network driver. This driver is used for a relatively common server NIC, the Intel Ethernet Controller I350.</p>"},{"location":"Linux/posts/Linux_network_stack/#initial-setup","title":"Initial setup","text":"<p>Devices have many ways of alerting the rest of the computer system that some work is ready for processing. In the case of network devices, it is common for the NIC to raise an IRQ to signal that a packet has arrived and is ready to be processed.</p> <p></p> <p>The initialization of the softIRQ system:</p> <ol> <li>softIRQ kernel threads are created (one per CPU): ksoftirq</li> <li>The ksoftirqd threads begin executing their processing loops in the <code>run_ksoftirqd</code> function</li> <li><code>softnet_data</code> structures are created (one per CPU), including <code>poll_list</code></li> <li><code>net_dev_init</code> then registers the <code>NET_RX_SOFTIRQ</code> softirq with the softirq system. The handler function  <code>net_rx_action</code> is the function the softirq kernel threads will execute to process packets.</li> </ol>"},{"location":"Linux/posts/Linux_network_stack/#data-arrives","title":"Data arrives","text":"<p>DMA:  a feature of computer systems that allows certain hardware subsystems to access main system memory independently of the central processing unit (CPU). [4]</p> <p>With DMA, the CPU first initiates the transfer, then it does other operations while the transfer is in progress, and it finally receives an interrupt from the DMA controller (DMAC) when the operation is done.</p> <p>Many hardware systems use DMA, including disk drive controllers, graphics cards, network cards and sound cards.</p> <p></p> <ol> <li>Data is received by the NIC from the network</li> <li>The NIC uses DMA to write the network data to RAM (ring buffer)</li> <li>The NIC raises IRQ</li> <li>The device driver's registered IRQ handlder is executed</li> <li>The IRQ is cleared on the NIC (in order to generate IRQs for new arriving packets)</li> <li>NAPI softIRQ poll loop is started with a call to <code>napi_schedule</code></li> </ol> <p>The call to <code>napi_schedule</code> triggers the step 5-8 in setup:</p> <ol> <li> <p><code>napi_schedule</code> adds the driver's NAPI poll structure to the <code>poll_list</code> for the current CPU</p> </li> <li> <p>The softirq pending bit is set, so that the ksoftirq process on this CPU knows that there are packets to process</p> </li> <li> <p><code>run_ksoftirqd</code> function (which is being run in a loop by the <code>ksoftirq</code> kernel thread) executes</p> </li> <li> <p><code>__do_softirq</code> is called which checks the pending bitfield, sees that a softIRQ is pending, and calls the handler registered for the pending softIRQ: <code>net_rx_action</code></p> </li> </ol> <p>NOTICE: the softIRQ kernel thread is executing <code>net_rx_action</code>, not the device driver IRQ handler</p> <p>SUMMARY: in general, the first two sections have done those things:</p> <ol> <li>create some threads to continuously execute some functions</li> <li>prepare some data structures for storage, execution, etc.</li> <li>register some handler functions for interrupts</li> <li>when events happen, raise interrupts, then change some flags. The functions in the loop will check those flags and call the handler functions</li> </ol>"},{"location":"Linux/posts/Linux_network_stack/#network-data-processing-begins","title":"Network data processing begins","text":"<p>NAPI</p> <p>NAPI is the event handling mechanism used by the Linux networking stack.</p> <p>In basic operation the device notifies the host about new events via an interrupt. The host then schedules a NAPI instance to process the events.</p> <p>Driver API</p> <p>The two most important elements of NAPI are the struct <code>napi_struct</code> and the associated poll method</p> <ul> <li>struct <code>napi_struct</code>: holds the state of the NAPI instance</li> <li>the method: the driver-specific event handler. The method will typically free Tx packets that have been transmitted and process newly received packets.</li> </ul> <p></p> <p>The <code>net_rx_action</code> function (called from the <code>ksoftirqd</code> kernel thread) will start to process any NAPI poll structures that have been added to the <code>poll_list</code> for the current CPU:</p> <ol> <li><code>net_rx_action</code> loop starts by checking the NAPI poll list for NAPI structures.</li> <li>The <code>budget</code> and elapsed time are checked to ensure that the softIRQ will not monopolize CPU time.</li> <li>The registered <code>poll</code> function is called. In this case, the function <code>igb_poll</code> was registered by the <code>igb</code> driver.</li> <li>The driver\u2019s <code>poll</code> function harvests packets from the ring buffer in RAM.</li> </ol>"},{"location":"Linux/posts/Linux_network_stack/#case-study-sending-data","title":"Case study: Sending data","text":""},{"location":"Linux/posts/Linux_network_stack/#struct-sk_buff","title":"struct sk_buff","text":"<p>All network-related queues and buffers in the kernel use a common data structure, struct sk_buff. This is a large struct containing all the control information required for the packet (datagram, cell, whatever).</p> <ul> <li><code>struct sk_buff</code> is a doubly linked list</li> <li><code>struct sk_buff_head</code> includes a head and a tail pointer to <code>sk_buff</code> elements</li> </ul> <p>Data structure hierarchy in Linux source code:</p> <pre><code>// network layer representation of sockets\nstruct sock {\n    struct sk_buff_head     sk_receive_queue;\n    struct sk_buff_head     sk_write_queue;\n    // ... \n};\n</code></pre> <p><code>sock</code> has receive queue and write queue.</p> <pre><code>struct sk_buff_head {\n    struct sk_buff  *next;\n    struct sk_buff  *prev;\n\n    __u32           qlen;\n    spinlock_t      lock;\n}\n</code></pre> <p><code>sk_buff_head</code> has head and tail pointer to the actual <code>sk_buff</code> elements. It defines a queue and each element's header is <code>sk_buff_head</code>. [7]</p> <pre><code>struct sk_buff {\n    struct sk_buff *next;\n    struct sk_buff *prev;\n\n    struct sock     *sk;    // record the socket assosciated with this SKB\n\n    // ...\n\n    unsigned int    truesize;   // used for socket buffer accounting\n    atomic_t        users;      // reference count SKB objects using the 'users' field\n    // These four pointers provide the core management \n    // of the linear packet data area of an SKB.\n    unsigned char       *head,\n                        *data,\n                        *tail,\n                        *end;\n}\n</code></pre>"},{"location":"Linux/posts/Linux_network_stack/#skb-data-layout","title":"SKB data layout","text":"<ul> <li><code>skb = alloc_skb(len, GFP_KERNEL);</code></li> </ul> <ul> <li><code>skb_reserve(skb, header_len);</code><ul> <li>for output packets, we reserve maximum bytes of header space</li> <li>when setting up receive packets that an ethernet device will DMA into, we typically call <code>skb_reserve(skb, NET_IP_ALIGN)</code><ul> <li>by default, <code>NET_IP_ALIGN</code> is <code>2</code> which means that after ethernet header, the protocol header will be aligned on at least a 4-byte boundary.</li> </ul> </li> </ul> </li> </ul> <ul> <li>push the UDP header to the front of the SKB<ul> <li>it will decrement the <code>skb-&gt;data</code> pointer</li> <li>which means that it will take up the end space of head room</li> </ul> </li> </ul> <pre><code>struct inet_sock *inet = inet_sk(sk); // create IP socket\nstruct flowi *fl = &amp;inet-&gt;cork.fl;\nstruct udphdr *uh;  // UDP header\n\nskb-&gt;h.raw = skb_push(skb, sizeof(struct udphdr)); // reserve udphdr space\nuh = skb-&gt;h.uh\nuh-&gt;source = fl-&gt;fl_ip_sport;                       // fill up udphdr attributes\nuh-&gt;dest = fl-&gt;fl_ip_dport;\nuh-&gt;len = htons(user_data_len);\nuh-&gt;check = 0;\nskb-&gt;csum = csum_partial((char *)uh,\n             sizeof(struct udphdr), skb-&gt;csum);     // compute checksum\nuh-&gt;check = csum_tcpudp_magic(fl-&gt;fl4_src, fl-&gt;fl4_dst,\n                  user_data_len, IPPROTO_UDP, skb-&gt;csum);\nif (uh-&gt;check == 0)\n    uh-&gt;check = -1;\n</code></pre> <ul> <li>push the IPv4 header to the front of the SKB<ul> <li>similarly, it will take up the end space of head room</li> <li>now this packet is basically ready to be pushed out to the device</li> </ul> </li> </ul> <pre><code>struct rtable *rt = inet-&gt;cork.rt;\nstruct iphdr *iph;\n\nskb-&gt;nh.raw = skb_push(skb, sizeof(struct iphdr));      // reserve iphdr space\niph = skb-&gt;nh.iph;\niph-&gt;version = 4;\niph-&gt;ihl = 5;\niph-&gt;tos = inet-&gt;tos;\niph-&gt;tot_len = htons(skb-&gt;len);\niph-&gt;frag_off = 0;\niph-&gt;id = htons(inet-&gt;id++);\niph-&gt;ttl = ip_select_ttl(inet, &amp;rt-&gt;u.dst);\niph-&gt;protocol = sk-&gt;sk_protocol; /* IPPROTO_UDP in this case */\niph-&gt;saddr = rt-&gt;rt_src;\niph-&gt;daddr = rt-&gt;rt_dst;\nip_send_check(iph);\n\nskb-&gt;priority = sk-&gt;sk_priority;\nskb-&gt;dst = dst_clone(&amp;rt-&gt;u.dst);\n</code></pre>"},{"location":"Linux/posts/Linux_network_stack/#tcp-output-engine-in-the-skb-point-of-view","title":"TCP output engine in the skb point of view","text":"<ul> <li><code>TCP socket</code> maintains a doubly linked list of the pending queue (<code>sk_write_queeu</code>) in red rectangle</li> <li><code>sk_send_head</code> points to the packet we have not sent out yet.<ul> <li>if receives ACK and window available, it will begin to send as many frames as we can.</li> </ul> </li> </ul> <ul> <li>in TCP output engine, all paths lead to <code>tcp_transmit_skb()</code> in all cases:<ul> <li>for the first time, retransmit, a SYN packet in response to a <code>connect()</code> syscall</li> </ul> </li> </ul>"},{"location":"Linux/posts/Linux_network_stack/#iptables","title":"iptables","text":""},{"location":"Linux/posts/Linux_network_stack/#references","title":"References","text":"<p>[1] Illustrated Guide to Monitoring and Tuning the Linux Networking Stack: Receiving Data</p> <p>[2] Monitoring and Tuning the Linux Networking Stack: Receiving Data</p> <p>[3] Linux networking stack from the ground up, part 1</p> <p>[4] Direct memory access (DMA)</p> <p>[5] https://wiki.linuxfoundation.org/networking/sk_buff</p> <p>[6] http://vger.kernel.org/~davem/skb_data.html</p> <p>[7] http://vger.kernel.org/~davem/skb.html</p> <p>[8] http://vger.kernel.org/~davem/skb_list.html</p> <p>[9] https://wiki.linuxfoundation.org/networking/kernel_flow</p> <p>[10] https://mp.weixin.qq.com/s/wThfD9th9e_-YGHJJ3HXNQ</p>"},{"location":"Linux/posts/linux_from_scratch/","title":"Learning OS from scratch","text":"<p>this article is based on #Linux \u6e90\u7801\u8da3\u8bfb (qq.com)</p> <p></p>"},{"location":"Linux/posts/linux_from_scratch/#section-1","title":"Section 1","text":""},{"location":"Linux/posts/linux_from_scratch/#power-up-load-data","title":"Power up &amp; Load data","text":"<p>The primordial task of boosting an OS is loading the \"OS\" (code, data, etc.) into memory based on the functionality of BIOS:</p> <ul> <li>BIOS loads the first sector of disk (512 bytes) into the memory at address 0x7c00 (magic number)<ul> <li>actually it is the binary code compiled of bootsect.s</li> </ul> </li> </ul>"},{"location":"Linux/posts/linux_from_scratch/#bootsects","title":"Bootsect.s","text":"<ul> <li>bootsect.s will set some registers (basically, code, segment, and stack) in CPU to specific pre-defined number to following loading</li> <li>bootsect.s then will load the following 4 + 240 sectors on disk to specific address in memory</li> <li>then will jump to address 0x90200, which is corresponding to setup.s file</li> </ul>"},{"location":"Linux/posts/linux_from_scratch/#setups","title":"setup.s","text":"<ul> <li>in setup.s, OS will read some information of devices<ul> <li>memory size, video-card data, display config, hd(hard disk) data</li> </ul> </li> <li>then move the data from [0x10000, 0x90000] to 0x0<ul> <li></li> </ul> </li> <li>now, the layout of memory is<ul> <li></li> </ul> </li> </ul>"},{"location":"Linux/posts/linux_from_scratch/#mode-convertion","title":"Mode convertion","text":"<ul> <li> <p>real mode (16 bit) -&gt; protected mode (32 bit)</p> </li> <li> <p>not core function, just skip this</p> </li> </ul>"},{"location":"Linux/posts/linux_from_scratch/#segmentation","title":"segmentation","text":"<ul> <li>CPU has 2 registers:<ul> <li>idt(interrupt discriptor table) -&gt; record the address of interrupt handler functions</li> <li>gdt(global discriptor table) -&gt; record some segment registers (code, data)</li> </ul> </li> </ul>"},{"location":"Linux/posts/linux_from_scratch/#paging","title":"paging","text":""},{"location":"Linux/posts/profiler/","title":"Profiler","text":""},{"location":"Linux/posts/profiler/#_1","title":"\u3010\u6587\u7ae0\u3011\u5e76\u884c\u6027\u80fd\u4f18\u5316","text":"<p>\u4e00\u6b21\u4e30\u5bcc\u591a\u5f69\u7684\u5e76\u884c\u6027\u80fd\u4f18\u5316\u8bb0\u5f55 - \u77e5\u4e4e (zhihu.com)</p> <p>by nbe - \u77e5\u4e4e (zhihu.com)</p>"},{"location":"Linux/posts/proxy/","title":"Proxy","text":""},{"location":"Linux/posts/proxy/#set-proxies-in-wsl2","title":"Set proxies in WSL2","text":"<p>It's really tough experience... The bugs and problems related to aspects of Windows fire wall, DNS, Clash...</p>"},{"location":"Linux/posts/proxy/#windows-fire-wall","title":"Windows fire wall","text":"<p>set inbound rules for WSL2 in FW</p> <p>restore DNS auto-generation in WSL2</p> <p>proxy scripts</p> <p>The first problem I encountered is that </p> <ul> <li>I tried to check the connectivity when I wanted to ping windows host machine from WSL2, there is no reply(very common). </li> <li>Then I STFW and got this: set inbound rules for WSL2 in FW, but still not work.</li> <li>(After a bunch of time figuring out why,) I occationally found that actually the Windows FW did not work, because I used ESET (another security app).</li> <li>Thus I deleted ESET and Windows FW's rules began to work (what a important milestone!) and I could ping the host from WSL.</li> </ul>"},{"location":"Linux/posts/proxy/#dns","title":"DNS","text":"<p>Then I noticed that my WSL2's DNS server had been changed (to 8.8.8.8) by myself before. But actually it should be auto-generated by <code>/etc/wsl.conf</code>.</p> <p>According to restore DNS auto-generation in WSL2, I <code>rm /etc/resolv.conf</code> and reboot WSL2 (by running <code>wsl --shutdown</code> in windows command line), I finally can get a DNS server that is Windows Host (which is dynamically assigned and will change from time to time).</p> <p>By now, I can ping or access web pages within GFW. The next step is to set up proxies in WSL2.</p>"},{"location":"Linux/posts/proxy/#clash","title":"Clash","text":"<p>I use clash as my proxy app in Windows host. And I turned on Allow LAN to allow my WSL2 which is in host's LAN to connect with Clash.</p> <p>And then I use this proxy scripts to enable WSL2 to set up proxies as Clash in Windows host.</p> <p>I used <code>wget</code> and <code>git clone</code> to the github and google, and I finally got responses!</p>"},{"location":"Linux/posts/proxy/#summary","title":"Summary","text":"<p>The network link topology is</p> <p>WSL (via vEthernet(WSL))-&gt; Windows --&gt; Clash proxy server(at 7890) --&gt; Internet </p>"},{"location":"Linux/posts/shell_scripts/","title":"Shell scripts","text":""},{"location":"Linux/posts/shell_scripts/#path-priority","title":"path priority","text":"<p>when you set</p> <pre><code>$ export PATH=\"/path/to/my/dir:$PATH\"\n</code></pre> <p>the priority will be:</p> <ul> <li> <p><code>/path/to/my/dir</code></p> </li> <li> <p>rest of <code>$PATH</code></p> </li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/07/16/learning-notes/","title":"Learning notes","text":"<p>My daily learning notes, including all aspects.</p>"},{"location":"blog/2024/07/16/learning-notes/#7162024","title":"7.16.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#wsl2","title":"WSL2","text":"<p>Windows\u4e0b\u7684\u865a\u62df\u5316\u65b9\u6848</p> <ul> <li>\u4f7f\u7528 vmware \u8fd8\u662f docker \u6765\u642d\u5efa Linux \u5b9e\u9a8c\u73af\u5883\uff1f</li> <li>[WSL 2] Multi WSL2 distributions use the same network namespace</li> <li>\u65e0\u56fe\u5f62\u754c\u9762\u7684 Linux \u80fd\u88c5\u865a\u62df\u673a\u4e48\uff1f</li> </ul>"},{"location":"blog/2024/07/16/learning-notes/#linux","title":"Linux\u5185\u6838\u683c\u5f0f\u4e0e\u542f\u52a8\u534f\u8bae","text":"<p>https://jia.je/os/2023/10/01/linux-boot-protocol/#linuxx86-boot-protocol</p>"},{"location":"blog/2024/07/16/learning-notes/#docker","title":"Docker","text":"<ul> <li> <p>How is Docker different from a virtual machine?</p> </li> <li> <p>From inside of a Docker container, how do I connect to the localhost of the machine?</p> </li> <li> <p>How do I get into a Docker container's shell?</p> </li> </ul>"},{"location":"blog/2024/07/16/learning-notes/#7172024","title":"7.17.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#www","title":"www","text":"<p>https://stackoverflow.com/questions/413490/what-is-the-point-of-www-in-web-urls</p>"},{"location":"blog/2024/07/16/learning-notes/#materials-for-mkdocs","title":"Materials for MkDocs","text":"<p>udpate my homepage build kits</p> <p>https://squidfunk.github.io/mkdocs-material/getting-started/#with-pip-latest</p>"},{"location":"blog/2024/07/16/learning-notes/#_1","title":"\u7cfb\u7edf\u5e95\u5c42","text":"<p>V2EX\u8ba8\u8bba\uff1ahttps://www.v2ex.com/t/282778</p> <p>Stanford Embedded OS: https://github.com/dddrrreee/cs140e-20win/tree/master/docs</p> <p>network debugging: https://www.manjusaka.blog/posts/2024/05/11/where-are-my-package/#%E6%9C%80%E5%90%8E</p>"},{"location":"blog/2024/07/16/learning-notes/#wslg","title":"<code>WSLg</code>","text":"<p>https://silaoa.github.io/2021/2021-06-02-WSLg%EF%BC%9A%E4%B8%BAWSL%E5%A2%9E%E5%85%89%E6%B7%BB%E5%BD%A9.html</p>"},{"location":"blog/2024/07/16/learning-notes/#git","title":"git","text":"<p>change remote:</p> <ul> <li>official https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories</li> <li>https://stackoverflow.com/questions/18801147/changing-the-git-remote-push-to-default</li> <li>https://stackoverflow.com/questions/2432764/how-do-i-change-the-uri-url-for-a-remote-git-repository</li> </ul>"},{"location":"blog/2024/07/16/learning-notes/#pip","title":"pip\u6362\u6e90","text":"<p>https://juejin.cn/post/6988116489739960334</p>"},{"location":"blog/2024/07/16/learning-notes/#7182024","title":"7.18.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#zsh-autocompletion","title":"zsh autocompletion","text":"<p>https://gist.github.com/n1snt/454b879b8f0b7995740ae04c5fb5b7df</p>"},{"location":"blog/2024/07/16/learning-notes/#7192024","title":"7.19.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#rust","title":"rust","text":"<p><code>mut</code> in function parameter: </p> <ul> <li>https://users.rust-lang.org/t/function-parameter-v-mut-t-or-mut-v-t/62410</li> <li>https://stackoverflow.com/questions/28587698/whats-the-difference-between-placing-mut-before-a-variable-name-and-after-the</li> </ul> <p>as constant pointer vs pointer to constant</p> <pre><code>// Rust          C/C++\n    a: &amp;T     == const T* const a; // can't mutate either\nmut a: &amp;T     == const T* a;       // can't mutate what is pointed to\n    a: &amp;mut T == T* const a;       // can't mutate pointer\nmut a: &amp;mut T == T* a;             // can mutate both\n</code></pre> <p><code>type</code> and <code>pattern</code>: https://users.rust-lang.org/t/function-parameter-v-mut-t-or-mut-v-t/62410</p>"},{"location":"blog/2024/07/16/learning-notes/#cloud-infra","title":"Cloud Infra","text":"<p>A bottom-up approach by Nick Cao@TUNA: https://www.youtube.com/watch?v=-lrkJOXAqoY</p>"},{"location":"blog/2024/07/16/learning-notes/#restic","title":"restic","text":"<p>back up: https://restic.readthedocs.io/en/stable/010_introduction.html</p>"},{"location":"blog/2024/07/16/learning-notes/#knot","title":"knot","text":"<p>authoritative DNS: https://www.knot-dns.cz/</p>"},{"location":"blog/2024/07/16/learning-notes/#7212024","title":"7.21.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#check-alias","title":"check alias","text":"<p>https://askubuntu.com/questions/102093/how-to-see-the-command-attached-to-a-bash-alias</p>"},{"location":"blog/2024/07/16/learning-notes/#fs-in-linux","title":"fs in linux","text":""},{"location":"blog/2024/07/16/learning-notes/#mount","title":"mount","text":"<p>mount a fs/partition (typically one partition has one fs, so used interchangeably): https://askubuntu.com/questions/20680/what-does-it-mean-to-mount-something</p>"},{"location":"blog/2024/07/16/learning-notes/#device","title":"device","text":"<p>In Unix world, everything is a file. So device is stored at <code>/dev</code>.</p> <p>https://askubuntu.com/questions/20680/what-does-it-mean-to-mount-something</p> <ul> <li><code>lsblk</code>: check disk(/partition) info</li> <li><code>df -h</code>: check fs-partition info</li> </ul>"},{"location":"blog/2024/07/16/learning-notes/#project-build","title":"project build","text":"<p><code>./configure</code>, <code>make</code>, and <code>make install</code>: https://thoughtbot.com/blog/the-magic-behind-configure-make-make-install</p>"},{"location":"blog/2024/07/16/learning-notes/#7222024","title":"7.22.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#python-shebang","title":"python shebang","text":"<p><code>#!/usr/bin/env python</code> vs <code>#!\\usr/local/bin/python</code></p> <p>https://mail.python.org/pipermail/tutor/2007-June/054816.html</p> <p>https://stackoverflow.com/questions/1352922/why-is-usr-bin-env-python-supposedly-more-correct-than-just-usr-bin-pyt</p> <p>TL; DR: The former will search <code>$PATH</code> for the actual place python installed, while the latter will use the path specified and fail if not find.</p>"},{"location":"blog/2024/07/16/learning-notes/#7242024","title":"7.24.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#git-remote","title":"git remote","text":"<p>Error message: <code>fatal: The current branch main has multiple upstream branches, refusing to push.</code></p> <p>https://stackoverflow.com/questions/13030714/git-fatal-the-current-branch-master-has-multiple-upstream-branches-refusing-t</p> <p><code>git config remote.origin.push HEAD</code></p> <p>Delete branch</p> <p>locally: <code>git branch -d &lt;branch-name&gt;</code></p> <p>remotely: <code>git push -d &lt;branch-name&gt;</code></p>"},{"location":"blog/2024/07/16/learning-notes/#cargo-dependency","title":"cargo dependency","text":"<p>A conprehensive explain: https://www.reddit.com/r/rust/comments/yrlvrq/why_are_dependency_crates_hidden/</p>"},{"location":"blog/2024/07/16/learning-notes/#7252024","title":"7.25.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#ubuntu-etcaptsourceslist-restores-default-version","title":"Ubuntu /etc/apt/sources.list restores default version","text":"<ul> <li>get distro name: </li> </ul> <p>https://askubuntu.com/a/443075</p> <p><code>lsb_release -cs</code></p> <ul> <li>Ubuntu 20.04 LTS (Focal) default sources.list:</li> </ul> <p>https://gist.github.com/ishad0w/788555191c7037e249a439542c53e170</p> <ul> <li>update apt package</li> </ul> <p><code>sudo apt update</code></p>"},{"location":"blog/2024/07/16/learning-notes/#git-clone-public-repo-and-push-to-private-repo","title":"Git: clone public repo and push to private repo","text":"<p>https://stackoverflow.com/questions/10065526/github-how-to-make-a-fork-of-public-repository-private</p> <p>Difference between <code>--bare</code> and <code>--mirror</code></p> <p>https://stackoverflow.com/questions/3959924/whats-the-difference-between-git-clone-mirror-and-git-clone-bare</p>"},{"location":"blog/2024/07/16/learning-notes/#git-branch-basics","title":"Git: branch basics","text":"<p>https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging</p> <p>Useful Git book: https://git-scm.com/book/en/v2</p>"},{"location":"blog/2024/07/16/learning-notes/#7272024","title":"7.27.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#linux-sysadmin-useful-resources","title":"Linux sysadmin useful resources","text":"<p>https://www.thegeekstuff.com/2010/12/50-unix-linux-sysadmin-tutorials/</p>"},{"location":"blog/2024/07/16/learning-notes/#linux-boot-process","title":"Linux boot process","text":"<p>concise one: https://www.thegeekstuff.com/2011/02/linux-boot-process/</p> <p>Ubuntu manpage: https://manpages.ubuntu.com/manpages/focal/en/man7/bootup.7.html</p> <p>Ubuntu wiki (concise): https://wiki.ubuntu.com/Booting</p>"},{"location":"blog/2024/07/16/learning-notes/#linux-kernel-compilation","title":"Linux kernel compilation","text":"<p>expert hacker: https://richardweiyang-2.gitbook.io/kernel-exploring/00_index</p>"},{"location":"blog/2024/07/16/learning-notes/#7292024","title":"7.29.2024","text":""},{"location":"blog/2024/07/16/learning-notes/#modern-c-guidelines","title":"Modern C++ guidelines","text":"<p>https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-philosophy</p>"},{"location":"blog/2024/07/16/learning-notes/#vscode-c-configuration","title":"VSCode C++ Configuration","text":"<p>https://zhuanlan.zhihu.com/p/669098443</p> <ul> <li>For C++ standard mismatch that caused the include error, we can<ul> <li><code>ctrl + shift + p</code> open console, choose C/C++: Edit Configuration (JSON), which will generate a <code>.vscode/c_cpp_properties.json</code> config file</li> <li>edit the keys (<code>cStandard</code> and <code>cppStandard</code>) inside <code>configurations</code> in that file,  to the standard the project actually is</li> </ul> </li> </ul>"},{"location":"blog/2024/02/01/misc-notes/","title":"Misc notes","text":"<p>My notes on miscellaneous topics.</p>"},{"location":"blog/2024/02/01/misc-notes/#non-blocking-read","title":"non-blocking read","text":"<p>c - Non-blocking call for reading descriptor - Stack Overflow</p> <ul> <li>set fd as non-blocking mode:</li> </ul> <pre><code>// directly begin to open\nfd = open(\"/path/to/file\", O_RDWR | O_NONBLOCK);\n\n// reset an existing fd with `fcntl`\nint flags = fcntl(fd, F_GETFL, 0); // get origin flags\nfcntl(fd, F_SETFL, flags | O_NONBLOCK); // add the new non-blocking flag\n\n// reset with `ioctl`\nconst int one = 1;\nioctl(fd, FIOBIO, &amp;one);\n</code></pre> <ul> <li>use <code>fd_set</code> to set the fds we want to control</li> </ul> <pre><code>#include &lt;sys/types.h&gt; // include some macros\n\nfd_set myfds;\nint fd1, fd2;\n// set all bits of fd_set to zero\nFD_ZERO(&amp;myfds);\n// pull up the bits we want\nFD_SET(fd1, &amp;myfds);\nFD_SET(fd2, &amp;myfds);\n</code></pre> <ul> <li>use <code>select()</code> to listen</li> </ul> <pre><code>// compute fd_max as an argument of select()\nint fd_max = 1 + fd1&lt;fd2?fd2:fd1;\n// use select to listen\nif(select(fd_max, &amp;myfds, (fd_set *)0, (fd_set *)0, (struct timeval *)0) &lt; 0) {\n    if(errno != EINTR) {\n        // Here you had some failures\n        // EINTR means that some interrupt happened...\n        // in this case we usually start over\n    }\n    else {\n        continue;\n    }\n}\n</code></pre> <ul> <li>use <code>FD_ISSET</code> to check availability</li> </ul> <pre><code>if(FD_ISSET(fd1, &amp;myfds)) {\n    // something available from fd1, read it and process it.\n}\nif(FD_ISSET(fd2, &amp;myfds)) {\n    // similarly\n}\n</code></pre>"},{"location":"blog/2024/02/01/misc-notes/#kill-zombies","title":"Kill zombies","text":"<p>a zombie process is the child process that was forked by its parent, and terminated before the parent calls <code>wait()</code> to cleanup its resources because OS will reserve some of the child's information that might be helpful to the parent. </p> <p>A good strategy is to prevent them happening:</p> <pre><code>#include &lt;sys/types.h&gt;  // include this before other headers\n#include &lt;sys/wait.h&gt;   // header for waitpid() and macros\n#include &lt;signal.h&gt;     // header for signal functions\n#include &lt;stdio.h&gt;      // header for fprintf()\n#include &lt;unistd.h&gt;     // header for fork()\n\nvoid sig_chld(int);     // prototype for our SIGCHLD hander\n\nint main() {\n    struct sigaction act;\n    pid_t pid;\n\n    // assign sig_chld as our SIGCHLD handler\n    act.sa_handler = sig_chld;\n\n    // we don't want to block any other signals in this example\n    sigemptyset(&amp;act.sa_mask);\n\n    // we're only interested in children that have terminated,\n    // not ones which have been stopped (eg user pressing Ctrl-Z)\n    act.sa_flags = SA_NOCLDSTOP;\n\n    // make these values effective. If we were writing a real\n    // application, we could probably save the old value instead of\n    // passing NULL\n    if (sigaction(SIGCHLD, &amp;act, NULL) &lt; 0) {\n        fprintf(stderr, \"sigaction failed\\n\");\n        return 1;\n    }\n\n    // Fork\n    if ((pid = fork()) &lt; 0) {\n        fprintf(stderr, \"fork failed\\n\");\n        return 1;\n    } else if (pid == 0) {\n        return 7;       // exit status = 7\n    } else {\n        sleep(10);      // give child time to finish\n        return 0;\n    }\n}\n\n// The signal handler function - only gets called when a SIGCHLD\n// is received, ie when a child terminates\nvoid sig_chld(int signo) {\n    int status, child_val;\n\n    // Wait for any child without blocking\n    if (watipid(-1, &amp;status, WNOHANG) &lt; 0) {\n        // calling standard I/O functions like fprintf() in a \n        // signal handler is not recommanded, but probably OK\n        // in toy programs like this one.\n        fprintf(stderr, \"waitpid failed\\n\");\n    }\n\n    // We now have the info in 'status' and can manipulate it using\n    // the macros in wait.h\n    if (WIFEXITED(status))  // did child exit normally?\n        child_val = WEXITSTATUS(status); // get child's exit status\n\n    printf(\"child's exited normally with status %d\\n\", child_val);\n}\n</code></pre>"},{"location":"blog/2024/02/01/misc-notes/#daemon-mode","title":"Daemon mode","text":"<ul> <li><code>fork()</code>: so that parent can exit, guarantee the new process is not a process group leader</li> </ul>"},{"location":"blog/archive/2024/","title":"July 2024","text":""}]}